-- database: :memory:
-- Tables
create table if not exists profiles (
  id uuid primary key references auth.users on delete cascade,
  email text unique,
  display_name text,
  avatar_url text,
  bio text,
  is_anonymous boolean default false,
  created_at timestamptz default now()
);

create table if not exists channels (
  id bigint generated by default as identity primary key,
  name text not null,
  description text,
  icon text,
  created_by uuid references profiles(id) on delete set null,
  is_dm boolean default false,
  dm_pair text unique,
  created_at timestamptz default now()
);

create table if not exists channel_members (
  channel_id bigint references channels(id) on delete cascade,
  user_id uuid references profiles(id) on delete cascade,
  last_seen timestamptz,
  created_at timestamptz default now(),
  primary key (channel_id, user_id)
);

create table if not exists messages (
  id bigint generated by default as identity primary key,
  channel_id bigint references channels(id) on delete cascade,
  user_id uuid references profiles(id) on delete set null,
  body text not null,
  created_at timestamptz default now()
);

create table if not exists friendships (
  user_id uuid references profiles(id) on delete cascade,
  friend_id uuid references profiles(id) on delete cascade,
  status text default 'pending',
  created_at timestamptz default now(),
  primary key (user_id, friend_id)
);

create table if not exists favorites (
  user_id uuid references profiles(id) on delete cascade,
  channel_id bigint references channels(id) on delete cascade,
  created_at timestamptz default now(),
  primary key (user_id, channel_id)
);

create table if not exists channel_roles (
  channel_id bigint references channels(id) on delete cascade,
  user_id uuid references profiles(id) on delete cascade,
  role text not null default 'user',
  granted_by uuid references profiles(id) on delete set null,
  created_at timestamptz default now(),
  primary key (channel_id, user_id),
  check (role in ('user', 'guardian', 'admin'))
);

create table if not exists channel_bans (
  id bigint generated by default as identity primary key,
  channel_id bigint references channels(id) on delete cascade,
  user_id uuid references profiles(id) on delete cascade,
  banned_by uuid references profiles(id) on delete set null,
  reason text,
  banned_until timestamptz not null,
  created_at timestamptz default now()
);

create table if not exists platform_bans (
  id bigint generated by default as identity primary key,
  user_id uuid references profiles(id) on delete cascade,
  banned_by uuid references profiles(id) on delete set null,
  reason text not null,
  banned_until timestamptz not null,
  created_at timestamptz default now()
);

create table if not exists moderation_notices (
  id bigint generated by default as identity primary key,
  user_id uuid references profiles(id) on delete cascade,
  issued_by uuid references profiles(id) on delete set null,
  channel_id bigint references channels(id) on delete set null,
  notice_type text not null,
  reason text,
  details text,
  seen boolean default false,
  created_at timestamptz default now()
);

create table if not exists moderation_requests (
  id bigint generated by default as identity primary key,
  channel_id bigint references channels(id) on delete cascade,
  requester_id uuid references profiles(id) on delete cascade,
  target_id uuid references profiles(id) on delete cascade,
  reason text,
  status text default 'pending',
  created_at timestamptz default now()
);

-- Safe updates for existing projects
alter table profiles add column if not exists avatar_url text;
alter table profiles add column if not exists bio text;
alter table profiles add column if not exists is_anonymous boolean default false;
alter table profiles add column if not exists global_role text default 'user';
alter table channels add column if not exists description text;
alter table channels add column if not exists icon text;
alter table channels add column if not exists rules text;
alter table channel_members add column if not exists last_seen timestamptz;

-- Realtime: ensure messages table is part of supabase_realtime publication
do $$
begin
  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'messages'
  ) then
    alter publication supabase_realtime add table messages;
  end if;
exception
  when undefined_object then
    null;
end $$;

-- Enable RLS
alter table profiles enable row level security;
alter table channels enable row level security;
alter table channel_members enable row level security;
alter table messages enable row level security;
alter table friendships enable row level security;
alter table favorites enable row level security;
alter table channel_roles enable row level security;
alter table channel_bans enable row level security;
alter table platform_bans enable row level security;
alter table moderation_notices enable row level security;
alter table moderation_requests enable row level security;

-- Profiles: allow authenticated to read (for friends + display names)
drop policy if exists "profiles_select_authenticated" on profiles;
drop policy if exists "profiles_select_own" on profiles;
drop policy if exists "profiles_insert_own" on profiles;
drop policy if exists "profiles_update_own" on profiles;
create policy "profiles_select_authenticated" on profiles
  for select using (auth.uid() is not null);
create policy "profiles_insert_own" on profiles
  for insert with check (id = auth.uid());
create policy "profiles_update_own" on profiles
  for update using (id = auth.uid());

-- Channels: any authenticated can read/create
drop policy if exists "channels_select_all" on channels;
drop policy if exists "channels_insert_authenticated" on channels;
create policy "channels_select_all" on channels
  for select using (
    auth.uid() is not null
    and (
      is_dm = false
      or position(auth.uid()::text in coalesce(dm_pair, '')) > 0
    )
  );
create policy "channels_insert_authenticated" on channels
  for insert with check (auth.uid() is not null);

-- Channel members:
-- users can only read their own membership rows
drop policy if exists "channel_members_select_authenticated" on channel_members;
drop policy if exists "channel_members_select_self" on channel_members;
drop policy if exists "channel_members_insert_self_or_owner" on channel_members;
drop policy if exists "channel_members_update_self" on channel_members;
create policy "channel_members_select_authenticated" on channel_members
  for select using (user_id = auth.uid());
create policy "channel_members_insert_self_or_owner" on channel_members
  for insert with check (
    (
      user_id = auth.uid()
      and exists (
        select 1 from channels c
        where c.id = channel_id and c.is_dm = false
      )
    )
    or exists (
      select 1 from channels c
      where c.id = channel_id and c.created_by = auth.uid()
    )
  );
create policy "channel_members_update_self" on channel_members
  for update using (user_id = auth.uid());

-- Messages: only members can read/send
drop policy if exists "messages_select_members" on messages;
drop policy if exists "messages_insert_members" on messages;
create policy "messages_select_members" on messages
  for select using (
    exists (
      select 1 from channel_members cm
      where cm.channel_id = messages.channel_id and cm.user_id = auth.uid()
    )
  );
create policy "messages_insert_members" on messages
  for insert with check (
    user_id = auth.uid()
    and exists (
      select 1 from channel_members cm
      where cm.channel_id = messages.channel_id and cm.user_id = auth.uid()
    )
  );

-- Friendships: requests + accept
drop policy if exists "friendships_select_own_or_target" on friendships;
drop policy if exists "friendships_insert_own" on friendships;
drop policy if exists "friendships_update_target" on friendships;
drop policy if exists "friendships_delete_target" on friendships;
create policy "friendships_select_own_or_target" on friendships
  for select using (user_id = auth.uid() or friend_id = auth.uid());
create policy "friendships_insert_own" on friendships
  for insert with check (user_id = auth.uid());
create policy "friendships_update_target" on friendships
  for update using (friend_id = auth.uid());
create policy "friendships_delete_target" on friendships
  for delete using (friend_id = auth.uid());

-- Favorites: only owner
drop policy if exists "favorites_select_own" on favorites;
drop policy if exists "favorites_insert_own" on favorites;
drop policy if exists "favorites_delete_own" on favorites;
create policy "favorites_select_own" on favorites
  for select using (user_id = auth.uid());
create policy "favorites_insert_own" on favorites
  for insert with check (user_id = auth.uid());
create policy "favorites_delete_own" on favorites
  for delete using (user_id = auth.uid());

drop policy if exists "channel_roles_select_auth" on channel_roles;
drop policy if exists "channel_roles_insert_auth" on channel_roles;
drop policy if exists "channel_roles_update_auth" on channel_roles;
drop policy if exists "channel_roles_delete_auth" on channel_roles;
create policy "channel_roles_select_auth" on channel_roles
  for select using (auth.uid() is not null);
create policy "channel_roles_insert_auth" on channel_roles
  for insert with check (auth.uid() is not null);
create policy "channel_roles_update_auth" on channel_roles
  for update using (auth.uid() is not null);
create policy "channel_roles_delete_auth" on channel_roles
  for delete using (auth.uid() is not null);

drop policy if exists "channel_bans_select_auth" on channel_bans;
drop policy if exists "channel_bans_insert_auth" on channel_bans;
drop policy if exists "channel_bans_update_auth" on channel_bans;
drop policy if exists "channel_bans_delete_auth" on channel_bans;
create policy "channel_bans_select_auth" on channel_bans
  for select using (auth.uid() is not null);
create policy "channel_bans_insert_auth" on channel_bans
  for insert with check (auth.uid() is not null);
create policy "channel_bans_update_auth" on channel_bans
  for update using (auth.uid() is not null);
create policy "channel_bans_delete_auth" on channel_bans
  for delete using (auth.uid() is not null);

drop policy if exists "platform_bans_select_auth" on platform_bans;
drop policy if exists "platform_bans_insert_auth" on platform_bans;
drop policy if exists "platform_bans_update_auth" on platform_bans;
drop policy if exists "platform_bans_delete_auth" on platform_bans;
create policy "platform_bans_select_auth" on platform_bans
  for select using (auth.uid() is not null);
create policy "platform_bans_insert_auth" on platform_bans
  for insert with check (auth.uid() is not null);
create policy "platform_bans_update_auth" on platform_bans
  for update using (auth.uid() is not null);
create policy "platform_bans_delete_auth" on platform_bans
  for delete using (auth.uid() is not null);

drop policy if exists "moderation_notices_select_own" on moderation_notices;
drop policy if exists "moderation_notices_insert_auth" on moderation_notices;
drop policy if exists "moderation_notices_update_own" on moderation_notices;
create policy "moderation_notices_select_own" on moderation_notices
  for select using (user_id = auth.uid());
create policy "moderation_notices_insert_auth" on moderation_notices
  for insert with check (auth.uid() is not null);
create policy "moderation_notices_update_own" on moderation_notices
  for update using (user_id = auth.uid());

drop policy if exists "moderation_requests_select_auth" on moderation_requests;
drop policy if exists "moderation_requests_insert_auth" on moderation_requests;
drop policy if exists "moderation_requests_update_auth" on moderation_requests;
create policy "moderation_requests_select_auth" on moderation_requests
  for select using (auth.uid() is not null);
create policy "moderation_requests_insert_auth" on moderation_requests
  for insert with check (auth.uid() is not null);
create policy "moderation_requests_update_auth" on moderation_requests
  for update using (auth.uid() is not null);
