-- database: :memory:
-- Tables
create table if not exists profiles (
  id uuid primary key references auth.users on delete cascade,
  email text unique,
  display_name text,
  avatar_url text,
  bio text,
  is_anonymous boolean default false,
  created_at timestamptz default now()
);

create table if not exists channels (
  id bigint generated by default as identity primary key,
  name text not null,
  description text,
  icon text,
  created_by uuid references profiles(id) on delete set null,
  is_dm boolean default false,
  dm_pair text unique,
  created_at timestamptz default now()
);

create table if not exists channel_members (
  channel_id bigint references channels(id) on delete cascade,
  user_id uuid references profiles(id) on delete cascade,
  last_seen timestamptz,
  created_at timestamptz default now(),
  primary key (channel_id, user_id)
);

create table if not exists messages (
  id bigint generated by default as identity primary key,
  channel_id bigint references channels(id) on delete cascade,
  user_id uuid references profiles(id) on delete set null,
  body text not null,
  created_at timestamptz default now()
);

create table if not exists friendships (
  user_id uuid references profiles(id) on delete cascade,
  friend_id uuid references profiles(id) on delete cascade,
  status text default 'pending',
  created_at timestamptz default now(),
  primary key (user_id, friend_id)
);

create table if not exists favorites (
  user_id uuid references profiles(id) on delete cascade,
  channel_id bigint references channels(id) on delete cascade,
  created_at timestamptz default now(),
  primary key (user_id, channel_id)
);

-- Safe updates for existing projects
alter table profiles add column if not exists avatar_url text;
alter table profiles add column if not exists bio text;
alter table profiles add column if not exists is_anonymous boolean default false;
alter table channels add column if not exists description text;
alter table channels add column if not exists icon text;
alter table channel_members add column if not exists last_seen timestamptz;

-- Realtime: ensure messages table is part of supabase_realtime publication
do $$
begin
  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'messages'
  ) then
    alter publication supabase_realtime add table messages;
  end if;
exception
  when undefined_object then
    null;
end $$;

-- Enable RLS
alter table profiles enable row level security;
alter table channels enable row level security;
alter table channel_members enable row level security;
alter table messages enable row level security;
alter table friendships enable row level security;
alter table favorites enable row level security;

-- Profiles: allow authenticated to read (for friends + display names)
drop policy if exists "profiles_select_authenticated" on profiles;
drop policy if exists "profiles_select_own" on profiles;
drop policy if exists "profiles_insert_own" on profiles;
drop policy if exists "profiles_update_own" on profiles;
create policy "profiles_select_authenticated" on profiles
  for select using (auth.uid() is not null);
create policy "profiles_insert_own" on profiles
  for insert with check (id = auth.uid());
create policy "profiles_update_own" on profiles
  for update using (id = auth.uid());

-- Channels: any authenticated can read/create
drop policy if exists "channels_select_all" on channels;
drop policy if exists "channels_insert_authenticated" on channels;
create policy "channels_select_all" on channels
  for select using (auth.uid() is not null);
create policy "channels_insert_authenticated" on channels
  for insert with check (auth.uid() is not null);

-- Channel members:
-- allow authenticated to read for counts, allow users to join themselves
drop policy if exists "channel_members_select_authenticated" on channel_members;
drop policy if exists "channel_members_select_self" on channel_members;
drop policy if exists "channel_members_insert_self_or_owner" on channel_members;
drop policy if exists "channel_members_update_self" on channel_members;
create policy "channel_members_select_authenticated" on channel_members
  for select using (auth.uid() is not null);
create policy "channel_members_insert_self_or_owner" on channel_members
  for insert with check (
    user_id = auth.uid()
    or exists (
      select 1 from channels c
      where c.id = channel_id and c.created_by = auth.uid()
    )
  );
create policy "channel_members_update_self" on channel_members
  for update using (user_id = auth.uid());

-- Messages: only members can read/send
drop policy if exists "messages_select_members" on messages;
drop policy if exists "messages_insert_members" on messages;
create policy "messages_select_members" on messages
  for select using (
    exists (
      select 1 from channel_members cm
      where cm.channel_id = messages.channel_id and cm.user_id = auth.uid()
    )
  );
create policy "messages_insert_members" on messages
  for insert with check (
    user_id = auth.uid()
    and exists (
      select 1 from channel_members cm
      where cm.channel_id = messages.channel_id and cm.user_id = auth.uid()
    )
  );

-- Friendships: requests + accept
drop policy if exists "friendships_select_own_or_target" on friendships;
drop policy if exists "friendships_insert_own" on friendships;
drop policy if exists "friendships_update_target" on friendships;
drop policy if exists "friendships_delete_target" on friendships;
create policy "friendships_select_own_or_target" on friendships
  for select using (user_id = auth.uid() or friend_id = auth.uid());
create policy "friendships_insert_own" on friendships
  for insert with check (user_id = auth.uid());
create policy "friendships_update_target" on friendships
  for update using (friend_id = auth.uid());
create policy "friendships_delete_target" on friendships
  for delete using (friend_id = auth.uid());

-- Favorites: only owner
drop policy if exists "favorites_select_own" on favorites;
drop policy if exists "favorites_insert_own" on favorites;
drop policy if exists "favorites_delete_own" on favorites;
create policy "favorites_select_own" on favorites
  for select using (user_id = auth.uid());
create policy "favorites_insert_own" on favorites
  for insert with check (user_id = auth.uid());
create policy "favorites_delete_own" on favorites
  for delete using (user_id = auth.uid());
